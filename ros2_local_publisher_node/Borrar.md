# Pantallas del funnel de portabilidad

La siguiente pantalla realizada es la tercera pantalla del funnel. Esta pantalla pertenece a la variante de Portabilidad y tiene como objetivo que el usuario ponga en un input el número que desea portar. Como dicho input contiene la misma lógica que la expresión regular para el teléfono nombrada previamente, solo tuvimos que introducir ese componente y copiar el código anteriormente mencionado. Gracias a la realización de esta pantalla, nos dimos cuenta de un bug en la comprobación del teléfono que posteriormente arreglamos también para el funnel anterior.

Voy a saltar a la sexta pantalla del funnel, ya que la pantalla 4 es una elección de si o no, donde si el usuario le da a si se muestra la quinta pantalla y si le da a no se muestra la sexta pantalla. La 5º pantalla es un formulario de datos personales, donde el usuario debe introducir su nombre, apellidos, fecha de nacimiento, y país de nacimiento. Esta pantalla es muy similar a la pantalla 6, por lo que voy a explicar las dos a la vez.

La quinta y la sexta son muy similares ya que ambas son formularios, por lo que la lógica de ambas es la misma. La lógica es la siguiente: cada campo del formulario tiene un tipo y es requerido. Si el usuario introduce un valor que no cumple con la lógica, se muestra un mensaje de error. Para ello, se ha creado un custom hook de formulario con la librería yup, como las anteriores ocasiones, que se encarga de comprobarlo. Este hook se actualiza en el evento de que el usuario introduzca un valor en el input, "onChange", y se comprueba si todos los datos son válidos cuando el usuario le da al botón de siguiente. De esta forma, si el usuario introduce un valor incorrecto, se muestra un tipo de mensaje de error, y si el usuario no introduce ningún valor, se muestra otro tipo de error.

Una peculiaridad de la sexta pantalla es que a la fecha la tuvimos que tratar campo a campo poniendo un máximo y un mínimo según corresponda, (dias: maximo 31 minimo 1; meses: máximo 12, mínimo 1; años: máximo new Date() .getFullYear(), mínimo 1900).

La séptima pantalla la llamamos IdentificationStep para diferenciarla de PersonalData, ya que aunque sea del mismo apartado, tienen diferente objetivo. En esta pantalla se le pide al usuario que elija un método de identificación, en este caso, solo se le da la opción de elegir entre DNI, NIE y pasaporte, ya que son los únicos métodos de identificación que se pueden usar en España. Para ello, se creó un componente que contiene un seleccionador con las tres opciones y un input para que el usuario introduzca su número de identificación (Véase la Figura 15). Para que el usuario no pueda introducir un número de identificación que no corresponda con el método elegido, se creó una expresión regular que comprueba que el número introducido es correcto según el método elegido.

La octava pantalla no se explicará porque es copiar otra pantalla existente en el funnel de aquisición y la novena pantalla se piden datos de contacto, pidiendo un número de teléfono y un email, ambos campos con sus respectivas validaciones usando expresiones regulares. Así mismo, dada la similitud con otras pantallas de los otros funnels, no se explicará en detalle.

En la decima pantalla (Véase Figura 20) tenemos 2 casuísticas. Entregar el IBAN, que está contrastado por una API que verifica su veracidad o pulsar el checkbox que dice “Prefiero contactar con un agente para facilitar esta información”. Esta pantalla tiene complejidad añadida porque divide el funnel de nuevo en otro camino, en este caso opcional. Si pulsamos una de las pantallas que veremos la pantalla de la Figura 21 que no está contabilizada en el funnel y otra que es una thank you page. Si ponemos un IBAN válido nos lleva a la pantalla de la Figura 22 que es un resumen de todos los datos introducidos en su completitud en el funnel de contratación online. Si ponemos un IBAN inválido no nos deja pulsar el botón de "Siguiente", obligando a que tengamos que pulsar el checkbox si no lo introducimos de manera correcta.

El input del IBAN tiene un autoformateo que se va realizando a medida que el usuario va introduciendo los números. Este autoformateo se realiza en el onChange del input, y se va realizando con un reemplazamiento de cada 4 caracteres añadir un espacio. Aquí hubieron algunas complicaciones ya que esta pequeña expresión regular funciona bien con guiones, pero con espacios no funcionaba. Para ello se tuvieron que realizar algunos controles de flujo, como por ejemplo tener en cuenta si el usuario está borrando. Esta comprobación del borrado solo funciona si el usuario borra el último carácter, ya que si borra un carácter intermedio, no se detecta y se sigue formateando, por lo que se queda atascado en los espacios intermedios, esto puede ser un bug o una feature según como se mire. Para comprobar que el IBAN es correcto, se usó un formulario como en anteriores ocasiones en el que se ha creado una expresión regular que va comprobando si, en el principio hay un "ES" y que todo el conjunto esté dividido en 8 grupos de 4 números separados por un espacio o sin espacios (aunque de esto se encarga el autoformateo). Si se cumple la expresión regular, el dato es válido y se le puede sar a siguiente.

A partir de la pantalla del IBAN hubo que poner como opcionales las pantallas de la Figura 21 y la Figura 22 y estas dependerán del checkbox que dice “Prefiero contactar con un agente para facilitar esta información”. Si el usuario pulsa el checkbox, se le muestra la pantalla de la Figura 21, y si no pulsa el checkbox, se le muestra la pantalla de la Figura 22. Para ello, enviamos el estado del checkbox por la query, y en función de eso, se muestra una pantalla u otra.

En la pantalla de la Figura 21 el usuario tiene que contartar con un agente, ya que no ha proporcionado el IBAN. Para ello, se le muestra un mensaje de que un agente se pondrá en contacto con él, y se le pide que introduzca su número de teléfono y su disponibilidad. Aquí si presionas el botón de siguiente, se muestra una pantalla de agradecimiento, pero si pulsas el botón del número de teléfono, si estás en móvil, te pone el número de teléfono en el teclado para que puedas llamar directamente, y si estás en escritorio a vista del usuario, no ocurre nada, para que el usuario pueda llamar si quiere. Siempre que se pulse dicho botón se considera que se ha perdido el lead, aunque si que puede ser un posible contrato, por lo que se manda un evento a analytics para que se pueda contabilizar cual es la opción más elegida.

La otra pantalla opcional es la del resumen de todos los datos. En esta ocasión si se ha enviado un IBAN y se procede a revisar si toda la información dada en el funnel y el producto elegido (que viene de otro funnel distinto no realidado por nosotros) es correcta. Para ello, se muestra un resumen de todos los datos introducidos, y se le pide al usuario que revise que todo es correcto. Si el usuario pulsa el botón de siguiente, se muestra una pantalla de agradecimiento, pero si le da a alguno de los botones que hay para editar, la línea que está al lado se combierte en un campo de texto para poder corregirlo.



Resumen
Desde la anterior reunión hasta ahora, nos han dado la responsabilidad de tener nuestro propio funnel de contratación online que tuvimos que hacer desde cero. Para ello, nos han dado permisos en el Figma para así poder ver el diseño de cada una de las pantallas que teníamos que desarrollar. En total, son 11 pantallas de las cuales 2 de ellas son opcionales y además consta de varias pantallas que difieren en su lógica con respecto al funnel de Adquisición. A fin de mantener una organización coherente, creamos tres pseudo-funnels a nivel de código, para adaptarnos a las diferentes elecciones que el usuario puede hacer. Aunque en realidad todas las pantallas de la sección de Contratación Online forman un único funnel, es conveniente denominar cada uno de estos caminos como funnels diferentes dentro del funnel principal con el fin de no perder en qué variante del funnel nos encontramos.

Hubieron pantallas repetitivas, por lo que no se nos hizo tan complicado, pero hubieron pantallas realmente complejas como la del IBAN, que tuvimos que hacer un autoformateo para que el usuario no tuviera que poner los espacios, y además tuvimos que hacer una expresión regular para comprobar que el IBAN es correcto. Otra pantalla que nos dio problemas fue la de la pantalla de resumen de todos los datos, ya que tuvimos que hacer un render condicional para que se mostrara un campo de texto editable si el usuario quería cambiar algún dato. 


Problemas y dificultades encontradas en el desarrollo de la aplicación.
Las mayores dificultades han sido problemas del día a día que hemos podido solucionar como por ejemplo, el autoformateo del IBAN, que no funcionaba cuando se borraban espacios, porque el replace detectaba que había que ponerlo, pero no detectaba que se estaba borrando, por lo que se quedaba atascado en los espacios intermedios. Otro ejemplo es que se nos dificultaron los tests usando mocks en los que teníamos que cambiar el estado de la query dentro del propio test pero pudimos solucionarlo con exito luego de investigar su funcionamiento mirando la documentación de Jest. De resto, no hemos tenido muchos problemas en los que nos hayamos atascado demasiado y no hemos tenido que hacer cambios de diseño, por lo que no hemos tenido que hacer cambios de código.
